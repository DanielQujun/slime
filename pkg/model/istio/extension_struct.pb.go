// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: networking/v1alpha3/extension_struct.proto

package istio

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type RateLimits struct {
	RateLimits           []*RateLimit `protobuf:"bytes,45,rep,name=rate_limits,json=rateLimits,proto3" json:"rate_limits,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RateLimits) Reset()         { *m = RateLimits{} }
func (m *RateLimits) String() string { return proto.CompactTextString(m) }
func (*RateLimits) ProtoMessage()    {}
func (*RateLimits) Descriptor() ([]byte, []int) {
	return fileDescriptor_2beeb35319d81284, []int{0}
}
func (m *RateLimits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimits.Merge(m, src)
}
func (m *RateLimits) XXX_Size() int {
	return m.Size()
}
func (m *RateLimits) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimits.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimits proto.InternalMessageInfo

func (m *RateLimits) GetRateLimits() []*RateLimit {
	if m != nil {
		return m.RateLimits
	}
	return nil
}

type RateLimit struct {
	// Refers to the stage set in the filter. The rate limit configuration only
	// applies to filters with the same stage number. The default stage number is
	// 0.
	//
	// .. note::
	//
	//   The filter supports a range of 0 - 10 inclusively for stage numbers.
	Stage int32 `protobuf:"varint,1,opt,name=stage,proto3" json:"stage,omitempty"`
	// The key to be set in runtime to disable this rate limit configuration.
	DisableKey string `protobuf:"bytes,2,opt,name=disable_key,json=disableKey,proto3" json:"disable_key,omitempty"`
	// A list of actions that are to be applied for this rate limit configuration.
	// Order matters as the actions are processed sequentially and the descriptor
	// is composed by appending descriptor entries in that sequence. If an action
	// cannot append a descriptor entry, no descriptor is generated for the
	// configuration. See :ref:`composing actions
	// <config_http_filters_rate_limit_composing_actions>` for additional documentation.
	Actions              []*RateLimit_Action `protobuf:"bytes,3,rep,name=actions,proto3" json:"actions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *RateLimit) Reset()         { *m = RateLimit{} }
func (m *RateLimit) String() string { return proto.CompactTextString(m) }
func (*RateLimit) ProtoMessage()    {}
func (*RateLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_2beeb35319d81284, []int{1}
}
func (m *RateLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit.Merge(m, src)
}
func (m *RateLimit) XXX_Size() int {
	return m.Size()
}
func (m *RateLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit proto.InternalMessageInfo

func (m *RateLimit) GetStage() int32 {
	if m != nil {
		return m.Stage
	}
	return 0
}

func (m *RateLimit) GetDisableKey() string {
	if m != nil {
		return m.DisableKey
	}
	return ""
}

func (m *RateLimit) GetActions() []*RateLimit_Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

type RateLimit_Action struct {
	// Types that are valid to be assigned to ActionSpecifier:
	//	*RateLimit_Action_SourceCluster_
	//	*RateLimit_Action_DestinationCluster_
	//	*RateLimit_Action_RequestHeaders_
	//	*RateLimit_Action_RemoteAddress_
	//	*RateLimit_Action_GenericKey_
	//	*RateLimit_Action_HeaderValueMatch_
	ActionSpecifier      isRateLimit_Action_ActionSpecifier `protobuf_oneof:"action_specifier"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *RateLimit_Action) Reset()         { *m = RateLimit_Action{} }
func (m *RateLimit_Action) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action) ProtoMessage()    {}
func (*RateLimit_Action) Descriptor() ([]byte, []int) {
	return fileDescriptor_2beeb35319d81284, []int{1, 0}
}
func (m *RateLimit_Action) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimit_Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimit_Action.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimit_Action) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit_Action.Merge(m, src)
}
func (m *RateLimit_Action) XXX_Size() int {
	return m.Size()
}
func (m *RateLimit_Action) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit_Action.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit_Action proto.InternalMessageInfo

type isRateLimit_Action_ActionSpecifier interface {
	isRateLimit_Action_ActionSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RateLimit_Action_SourceCluster_ struct {
	SourceCluster *RateLimit_Action_SourceCluster `protobuf:"bytes,1,opt,name=source_cluster,json=sourceCluster,proto3,oneof"`
}
type RateLimit_Action_DestinationCluster_ struct {
	DestinationCluster *RateLimit_Action_DestinationCluster `protobuf:"bytes,2,opt,name=destination_cluster,json=destinationCluster,proto3,oneof"`
}
type RateLimit_Action_RequestHeaders_ struct {
	RequestHeaders *RateLimit_Action_RequestHeaders `protobuf:"bytes,3,opt,name=request_headers,json=requestHeaders,proto3,oneof"`
}
type RateLimit_Action_RemoteAddress_ struct {
	RemoteAddress *RateLimit_Action_RemoteAddress `protobuf:"bytes,4,opt,name=remote_address,json=remoteAddress,proto3,oneof"`
}
type RateLimit_Action_GenericKey_ struct {
	GenericKey *RateLimit_Action_GenericKey `protobuf:"bytes,5,opt,name=generic_key,json=genericKey,proto3,oneof"`
}
type RateLimit_Action_HeaderValueMatch_ struct {
	HeaderValueMatch *RateLimit_Action_HeaderValueMatch `protobuf:"bytes,6,opt,name=header_value_match,json=headerValueMatch,proto3,oneof"`
}

func (*RateLimit_Action_SourceCluster_) isRateLimit_Action_ActionSpecifier()      {}
func (*RateLimit_Action_DestinationCluster_) isRateLimit_Action_ActionSpecifier() {}
func (*RateLimit_Action_RequestHeaders_) isRateLimit_Action_ActionSpecifier()     {}
func (*RateLimit_Action_RemoteAddress_) isRateLimit_Action_ActionSpecifier()      {}
func (*RateLimit_Action_GenericKey_) isRateLimit_Action_ActionSpecifier()         {}
func (*RateLimit_Action_HeaderValueMatch_) isRateLimit_Action_ActionSpecifier()   {}

func (m *RateLimit_Action) GetActionSpecifier() isRateLimit_Action_ActionSpecifier {
	if m != nil {
		return m.ActionSpecifier
	}
	return nil
}

func (m *RateLimit_Action) GetSourceCluster() *RateLimit_Action_SourceCluster {
	if x, ok := m.GetActionSpecifier().(*RateLimit_Action_SourceCluster_); ok {
		return x.SourceCluster
	}
	return nil
}

func (m *RateLimit_Action) GetDestinationCluster() *RateLimit_Action_DestinationCluster {
	if x, ok := m.GetActionSpecifier().(*RateLimit_Action_DestinationCluster_); ok {
		return x.DestinationCluster
	}
	return nil
}

func (m *RateLimit_Action) GetRequestHeaders() *RateLimit_Action_RequestHeaders {
	if x, ok := m.GetActionSpecifier().(*RateLimit_Action_RequestHeaders_); ok {
		return x.RequestHeaders
	}
	return nil
}

func (m *RateLimit_Action) GetRemoteAddress() *RateLimit_Action_RemoteAddress {
	if x, ok := m.GetActionSpecifier().(*RateLimit_Action_RemoteAddress_); ok {
		return x.RemoteAddress
	}
	return nil
}

func (m *RateLimit_Action) GetGenericKey() *RateLimit_Action_GenericKey {
	if x, ok := m.GetActionSpecifier().(*RateLimit_Action_GenericKey_); ok {
		return x.GenericKey
	}
	return nil
}

func (m *RateLimit_Action) GetHeaderValueMatch() *RateLimit_Action_HeaderValueMatch {
	if x, ok := m.GetActionSpecifier().(*RateLimit_Action_HeaderValueMatch_); ok {
		return x.HeaderValueMatch
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RateLimit_Action) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RateLimit_Action_OneofMarshaler, _RateLimit_Action_OneofUnmarshaler, _RateLimit_Action_OneofSizer, []interface{}{
		(*RateLimit_Action_SourceCluster_)(nil),
		(*RateLimit_Action_DestinationCluster_)(nil),
		(*RateLimit_Action_RequestHeaders_)(nil),
		(*RateLimit_Action_RemoteAddress_)(nil),
		(*RateLimit_Action_GenericKey_)(nil),
		(*RateLimit_Action_HeaderValueMatch_)(nil),
	}
}

func _RateLimit_Action_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RateLimit_Action)
	// action_specifier
	switch x := m.ActionSpecifier.(type) {
	case *RateLimit_Action_SourceCluster_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SourceCluster); err != nil {
			return err
		}
	case *RateLimit_Action_DestinationCluster_:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DestinationCluster); err != nil {
			return err
		}
	case *RateLimit_Action_RequestHeaders_:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RequestHeaders); err != nil {
			return err
		}
	case *RateLimit_Action_RemoteAddress_:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RemoteAddress); err != nil {
			return err
		}
	case *RateLimit_Action_GenericKey_:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GenericKey); err != nil {
			return err
		}
	case *RateLimit_Action_HeaderValueMatch_:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HeaderValueMatch); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RateLimit_Action.ActionSpecifier has unexpected type %T", x)
	}
	return nil
}

func _RateLimit_Action_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RateLimit_Action)
	switch tag {
	case 1: // action_specifier.source_cluster
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RateLimit_Action_SourceCluster)
		err := b.DecodeMessage(msg)
		m.ActionSpecifier = &RateLimit_Action_SourceCluster_{msg}
		return true, err
	case 2: // action_specifier.destination_cluster
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RateLimit_Action_DestinationCluster)
		err := b.DecodeMessage(msg)
		m.ActionSpecifier = &RateLimit_Action_DestinationCluster_{msg}
		return true, err
	case 3: // action_specifier.request_headers
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RateLimit_Action_RequestHeaders)
		err := b.DecodeMessage(msg)
		m.ActionSpecifier = &RateLimit_Action_RequestHeaders_{msg}
		return true, err
	case 4: // action_specifier.remote_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RateLimit_Action_RemoteAddress)
		err := b.DecodeMessage(msg)
		m.ActionSpecifier = &RateLimit_Action_RemoteAddress_{msg}
		return true, err
	case 5: // action_specifier.generic_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RateLimit_Action_GenericKey)
		err := b.DecodeMessage(msg)
		m.ActionSpecifier = &RateLimit_Action_GenericKey_{msg}
		return true, err
	case 6: // action_specifier.header_value_match
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RateLimit_Action_HeaderValueMatch)
		err := b.DecodeMessage(msg)
		m.ActionSpecifier = &RateLimit_Action_HeaderValueMatch_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RateLimit_Action_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RateLimit_Action)
	// action_specifier
	switch x := m.ActionSpecifier.(type) {
	case *RateLimit_Action_SourceCluster_:
		s := proto.Size(x.SourceCluster)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RateLimit_Action_DestinationCluster_:
		s := proto.Size(x.DestinationCluster)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RateLimit_Action_RequestHeaders_:
		s := proto.Size(x.RequestHeaders)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RateLimit_Action_RemoteAddress_:
		s := proto.Size(x.RemoteAddress)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RateLimit_Action_GenericKey_:
		s := proto.Size(x.GenericKey)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RateLimit_Action_HeaderValueMatch_:
		s := proto.Size(x.HeaderValueMatch)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// The following descriptor entry is appended to the descriptor:
//
// .. code-block:: cpp
//
//   ("source_cluster", "<local service cluster>")
//
// <local service cluster> is derived from the :option:`--service-cluster` option.
type RateLimit_Action_SourceCluster struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RateLimit_Action_SourceCluster) Reset()         { *m = RateLimit_Action_SourceCluster{} }
func (m *RateLimit_Action_SourceCluster) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action_SourceCluster) ProtoMessage()    {}
func (*RateLimit_Action_SourceCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_2beeb35319d81284, []int{1, 0, 0}
}
func (m *RateLimit_Action_SourceCluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimit_Action_SourceCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimit_Action_SourceCluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimit_Action_SourceCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit_Action_SourceCluster.Merge(m, src)
}
func (m *RateLimit_Action_SourceCluster) XXX_Size() int {
	return m.Size()
}
func (m *RateLimit_Action_SourceCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit_Action_SourceCluster.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit_Action_SourceCluster proto.InternalMessageInfo

// The following descriptor entry is appended to the descriptor:
//
// .. code-block:: cpp
//
//   ("destination_cluster", "<routed target cluster>")
//
// Once a request matches against a route table rule, a routed cluster is determined by one of
// the following :ref:`route table configuration <envoy_api_msg_RouteConfiguration>`
// settings:
//
// * :ref:`cluster <envoy_api_field_route.RouteAction.cluster>` indicates the upstream cluster
//   to route to.
// * :ref:`weighted_clusters <envoy_api_field_route.RouteAction.weighted_clusters>`
//   chooses a cluster randomly from a set of clusters with attributed weight.
// * :ref:`cluster_header <envoy_api_field_route.RouteAction.cluster_header>` indicates which
//   header in the request contains the target cluster.
type RateLimit_Action_DestinationCluster struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RateLimit_Action_DestinationCluster) Reset()         { *m = RateLimit_Action_DestinationCluster{} }
func (m *RateLimit_Action_DestinationCluster) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action_DestinationCluster) ProtoMessage()    {}
func (*RateLimit_Action_DestinationCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_2beeb35319d81284, []int{1, 0, 1}
}
func (m *RateLimit_Action_DestinationCluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimit_Action_DestinationCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimit_Action_DestinationCluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimit_Action_DestinationCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit_Action_DestinationCluster.Merge(m, src)
}
func (m *RateLimit_Action_DestinationCluster) XXX_Size() int {
	return m.Size()
}
func (m *RateLimit_Action_DestinationCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit_Action_DestinationCluster.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit_Action_DestinationCluster proto.InternalMessageInfo

// The following descriptor entry is appended when a header contains a key that matches the
// *header_name*:
//
// .. code-block:: cpp
//
//   ("<descriptor_key>", "<header_value_queried_from_header>")
type RateLimit_Action_RequestHeaders struct {
	// The header name to be queried from the request headers. The header’s
	// value is used to populate the value of the descriptor entry for the
	// descriptor_key.
	HeaderName string `protobuf:"bytes,1,opt,name=header_name,json=headerName,proto3" json:"header_name,omitempty"`
	// The key to use in the descriptor entry.
	DescriptorKey        string   `protobuf:"bytes,2,opt,name=descriptor_key,json=descriptorKey,proto3" json:"descriptor_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RateLimit_Action_RequestHeaders) Reset()         { *m = RateLimit_Action_RequestHeaders{} }
func (m *RateLimit_Action_RequestHeaders) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action_RequestHeaders) ProtoMessage()    {}
func (*RateLimit_Action_RequestHeaders) Descriptor() ([]byte, []int) {
	return fileDescriptor_2beeb35319d81284, []int{1, 0, 2}
}
func (m *RateLimit_Action_RequestHeaders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimit_Action_RequestHeaders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimit_Action_RequestHeaders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimit_Action_RequestHeaders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit_Action_RequestHeaders.Merge(m, src)
}
func (m *RateLimit_Action_RequestHeaders) XXX_Size() int {
	return m.Size()
}
func (m *RateLimit_Action_RequestHeaders) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit_Action_RequestHeaders.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit_Action_RequestHeaders proto.InternalMessageInfo

func (m *RateLimit_Action_RequestHeaders) GetHeaderName() string {
	if m != nil {
		return m.HeaderName
	}
	return ""
}

func (m *RateLimit_Action_RequestHeaders) GetDescriptorKey() string {
	if m != nil {
		return m.DescriptorKey
	}
	return ""
}

// The following descriptor entry is appended to the descriptor and is populated using the
// trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
//
// .. code-block:: cpp
//
//   ("remote_address", "<trusted address from x-forwarded-for>")
type RateLimit_Action_RemoteAddress struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RateLimit_Action_RemoteAddress) Reset()         { *m = RateLimit_Action_RemoteAddress{} }
func (m *RateLimit_Action_RemoteAddress) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action_RemoteAddress) ProtoMessage()    {}
func (*RateLimit_Action_RemoteAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_2beeb35319d81284, []int{1, 0, 3}
}
func (m *RateLimit_Action_RemoteAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimit_Action_RemoteAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimit_Action_RemoteAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimit_Action_RemoteAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit_Action_RemoteAddress.Merge(m, src)
}
func (m *RateLimit_Action_RemoteAddress) XXX_Size() int {
	return m.Size()
}
func (m *RateLimit_Action_RemoteAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit_Action_RemoteAddress.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit_Action_RemoteAddress proto.InternalMessageInfo

// The following descriptor entry is appended to the descriptor:
//
// .. code-block:: cpp
//
//   ("generic_key", "<descriptor_value>")
type RateLimit_Action_GenericKey struct {
	// The value to use in the descriptor entry.
	DescriptorValue      string   `protobuf:"bytes,1,opt,name=descriptor_value,json=descriptorValue,proto3" json:"descriptor_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RateLimit_Action_GenericKey) Reset()         { *m = RateLimit_Action_GenericKey{} }
func (m *RateLimit_Action_GenericKey) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action_GenericKey) ProtoMessage()    {}
func (*RateLimit_Action_GenericKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_2beeb35319d81284, []int{1, 0, 4}
}
func (m *RateLimit_Action_GenericKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimit_Action_GenericKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimit_Action_GenericKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimit_Action_GenericKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit_Action_GenericKey.Merge(m, src)
}
func (m *RateLimit_Action_GenericKey) XXX_Size() int {
	return m.Size()
}
func (m *RateLimit_Action_GenericKey) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit_Action_GenericKey.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit_Action_GenericKey proto.InternalMessageInfo

func (m *RateLimit_Action_GenericKey) GetDescriptorValue() string {
	if m != nil {
		return m.DescriptorValue
	}
	return ""
}

// The following descriptor entry is appended to the descriptor:
//
// .. code-block:: cpp
//
//   ("header_match", "<descriptor_value>")
type RateLimit_Action_HeaderValueMatch struct {
	// The value to use in the descriptor entry.
	DescriptorValue string `protobuf:"bytes,1,opt,name=descriptor_value,json=descriptorValue,proto3" json:"descriptor_value,omitempty"`
	// If set to true, the action will append a descriptor entry when the
	// request matches the headers. If set to false, the action will append a
	// descriptor entry when the request does not match the headers. The
	// default value is true.
	ExpectMatch *types.BoolValue `protobuf:"bytes,2,opt,name=expect_match,json=expectMatch,proto3" json:"expect_match,omitempty"`
	// Specifies a set of headers that the rate limit action should match
	// on. The action will check the request’s headers against all the
	// specified headers in the config. A match will happen if all the
	// headers in the config are present in the request with the same values
	// (or based on presence if the value field is not in the config).
	Headers              []*HeaderMatcher `protobuf:"bytes,3,rep,name=headers,proto3" json:"headers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RateLimit_Action_HeaderValueMatch) Reset()         { *m = RateLimit_Action_HeaderValueMatch{} }
func (m *RateLimit_Action_HeaderValueMatch) String() string { return proto.CompactTextString(m) }
func (*RateLimit_Action_HeaderValueMatch) ProtoMessage()    {}
func (*RateLimit_Action_HeaderValueMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_2beeb35319d81284, []int{1, 0, 5}
}
func (m *RateLimit_Action_HeaderValueMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimit_Action_HeaderValueMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimit_Action_HeaderValueMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimit_Action_HeaderValueMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit_Action_HeaderValueMatch.Merge(m, src)
}
func (m *RateLimit_Action_HeaderValueMatch) XXX_Size() int {
	return m.Size()
}
func (m *RateLimit_Action_HeaderValueMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit_Action_HeaderValueMatch.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit_Action_HeaderValueMatch proto.InternalMessageInfo

func (m *RateLimit_Action_HeaderValueMatch) GetDescriptorValue() string {
	if m != nil {
		return m.DescriptorValue
	}
	return ""
}

func (m *RateLimit_Action_HeaderValueMatch) GetExpectMatch() *types.BoolValue {
	if m != nil {
		return m.ExpectMatch
	}
	return nil
}

func (m *RateLimit_Action_HeaderValueMatch) GetHeaders() []*HeaderMatcher {
	if m != nil {
		return m.Headers
	}
	return nil
}

// .. attention::
//
//   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1 *Host*
//   header. Thus, if attempting to match on *Host*, match on *:authority* instead.
//
// .. attention::
//
//   To route on HTTP method, use the special HTTP/2 *:method* header. This works for both
//   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,
//
//   .. code-block:: json
//
//     {
//       "name": ":method",
//       "exact_match": "POST"
//     }
//
// .. attention::
//   In the absence of any header match specifier, match will default to :ref:`present_match
//   <envoy_api_field_route.HeaderMatcher.present_match>`. i.e, a request that has the :ref:`name
//   <envoy_api_field_route.HeaderMatcher.name>` header will match, regardless of the header's
//   value.
//
type HeaderMatcher struct {
	// Specifies the name of the header in the request.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Specifies how the header match will be performed to route the request.
	//
	// Types that are valid to be assigned to HeaderMatchSpecifier:
	//	*HeaderMatcher_ExactMatch
	//	*HeaderMatcher_RegexMatch
	//	*HeaderMatcher_RangeMatch
	//	*HeaderMatcher_PresentMatch
	//	*HeaderMatcher_PrefixMatch
	//	*HeaderMatcher_SuffixMatch
	HeaderMatchSpecifier isHeaderMatcher_HeaderMatchSpecifier `protobuf_oneof:"header_match_specifier"`
	// If specified, the match result will be inverted before checking. Defaults to false.
	//
	// Examples:
	//
	// * The regex *\d{3}* does not match the value *1234*, so it will match when inverted.
	// * The range [-10,0) will match the value -1, so it will not match when inverted.
	InvertMatch          bool     `protobuf:"varint,8,opt,name=invert_match,json=invertMatch,proto3" json:"invert_match,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeaderMatcher) Reset()         { *m = HeaderMatcher{} }
func (m *HeaderMatcher) String() string { return proto.CompactTextString(m) }
func (*HeaderMatcher) ProtoMessage()    {}
func (*HeaderMatcher) Descriptor() ([]byte, []int) {
	return fileDescriptor_2beeb35319d81284, []int{2}
}
func (m *HeaderMatcher) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderMatcher) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeaderMatcher.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeaderMatcher) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderMatcher.Merge(m, src)
}
func (m *HeaderMatcher) XXX_Size() int {
	return m.Size()
}
func (m *HeaderMatcher) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderMatcher.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderMatcher proto.InternalMessageInfo

type isHeaderMatcher_HeaderMatchSpecifier interface {
	isHeaderMatcher_HeaderMatchSpecifier()
	MarshalTo([]byte) (int, error)
	Size() int
}

type HeaderMatcher_ExactMatch struct {
	ExactMatch string `protobuf:"bytes,4,opt,name=exact_match,json=exactMatch,proto3,oneof"`
}
type HeaderMatcher_RegexMatch struct {
	RegexMatch string `protobuf:"bytes,5,opt,name=regex_match,json=regexMatch,proto3,oneof"`
}
type HeaderMatcher_RangeMatch struct {
	RangeMatch *HeaderMatcher_Int64Range `protobuf:"bytes,6,opt,name=range_match,json=rangeMatch,proto3,oneof"`
}
type HeaderMatcher_PresentMatch struct {
	PresentMatch bool `protobuf:"varint,7,opt,name=present_match,json=presentMatch,proto3,oneof"`
}
type HeaderMatcher_PrefixMatch struct {
	PrefixMatch string `protobuf:"bytes,9,opt,name=prefix_match,json=prefixMatch,proto3,oneof"`
}
type HeaderMatcher_SuffixMatch struct {
	SuffixMatch string `protobuf:"bytes,10,opt,name=suffix_match,json=suffixMatch,proto3,oneof"`
}

func (*HeaderMatcher_ExactMatch) isHeaderMatcher_HeaderMatchSpecifier()   {}
func (*HeaderMatcher_RegexMatch) isHeaderMatcher_HeaderMatchSpecifier()   {}
func (*HeaderMatcher_RangeMatch) isHeaderMatcher_HeaderMatchSpecifier()   {}
func (*HeaderMatcher_PresentMatch) isHeaderMatcher_HeaderMatchSpecifier() {}
func (*HeaderMatcher_PrefixMatch) isHeaderMatcher_HeaderMatchSpecifier()  {}
func (*HeaderMatcher_SuffixMatch) isHeaderMatcher_HeaderMatchSpecifier()  {}

func (m *HeaderMatcher) GetHeaderMatchSpecifier() isHeaderMatcher_HeaderMatchSpecifier {
	if m != nil {
		return m.HeaderMatchSpecifier
	}
	return nil
}

func (m *HeaderMatcher) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeaderMatcher) GetExactMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcher_ExactMatch); ok {
		return x.ExactMatch
	}
	return ""
}

func (m *HeaderMatcher) GetRegexMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcher_RegexMatch); ok {
		return x.RegexMatch
	}
	return ""
}

func (m *HeaderMatcher) GetRangeMatch() *HeaderMatcher_Int64Range {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcher_RangeMatch); ok {
		return x.RangeMatch
	}
	return nil
}

func (m *HeaderMatcher) GetPresentMatch() bool {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcher_PresentMatch); ok {
		return x.PresentMatch
	}
	return false
}

func (m *HeaderMatcher) GetPrefixMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcher_PrefixMatch); ok {
		return x.PrefixMatch
	}
	return ""
}

func (m *HeaderMatcher) GetSuffixMatch() string {
	if x, ok := m.GetHeaderMatchSpecifier().(*HeaderMatcher_SuffixMatch); ok {
		return x.SuffixMatch
	}
	return ""
}

func (m *HeaderMatcher) GetInvertMatch() bool {
	if m != nil {
		return m.InvertMatch
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HeaderMatcher) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HeaderMatcher_OneofMarshaler, _HeaderMatcher_OneofUnmarshaler, _HeaderMatcher_OneofSizer, []interface{}{
		(*HeaderMatcher_ExactMatch)(nil),
		(*HeaderMatcher_RegexMatch)(nil),
		(*HeaderMatcher_RangeMatch)(nil),
		(*HeaderMatcher_PresentMatch)(nil),
		(*HeaderMatcher_PrefixMatch)(nil),
		(*HeaderMatcher_SuffixMatch)(nil),
	}
}

func _HeaderMatcher_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HeaderMatcher)
	// header_match_specifier
	switch x := m.HeaderMatchSpecifier.(type) {
	case *HeaderMatcher_ExactMatch:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ExactMatch)
	case *HeaderMatcher_RegexMatch:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.RegexMatch)
	case *HeaderMatcher_RangeMatch:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RangeMatch); err != nil {
			return err
		}
	case *HeaderMatcher_PresentMatch:
		t := uint64(0)
		if x.PresentMatch {
			t = 1
		}
		_ = b.EncodeVarint(7<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *HeaderMatcher_PrefixMatch:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.PrefixMatch)
	case *HeaderMatcher_SuffixMatch:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.SuffixMatch)
	case nil:
	default:
		return fmt.Errorf("HeaderMatcher.HeaderMatchSpecifier has unexpected type %T", x)
	}
	return nil
}

func _HeaderMatcher_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HeaderMatcher)
	switch tag {
	case 4: // header_match_specifier.exact_match
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.HeaderMatchSpecifier = &HeaderMatcher_ExactMatch{x}
		return true, err
	case 5: // header_match_specifier.regex_match
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.HeaderMatchSpecifier = &HeaderMatcher_RegexMatch{x}
		return true, err
	case 6: // header_match_specifier.range_match
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HeaderMatcher_Int64Range)
		err := b.DecodeMessage(msg)
		m.HeaderMatchSpecifier = &HeaderMatcher_RangeMatch{msg}
		return true, err
	case 7: // header_match_specifier.present_match
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.HeaderMatchSpecifier = &HeaderMatcher_PresentMatch{x != 0}
		return true, err
	case 9: // header_match_specifier.prefix_match
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.HeaderMatchSpecifier = &HeaderMatcher_PrefixMatch{x}
		return true, err
	case 10: // header_match_specifier.suffix_match
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.HeaderMatchSpecifier = &HeaderMatcher_SuffixMatch{x}
		return true, err
	default:
		return false, nil
	}
}

func _HeaderMatcher_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HeaderMatcher)
	// header_match_specifier
	switch x := m.HeaderMatchSpecifier.(type) {
	case *HeaderMatcher_ExactMatch:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.ExactMatch)))
		n += len(x.ExactMatch)
	case *HeaderMatcher_RegexMatch:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.RegexMatch)))
		n += len(x.RegexMatch)
	case *HeaderMatcher_RangeMatch:
		s := proto.Size(x.RangeMatch)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HeaderMatcher_PresentMatch:
		n += 1 // tag and wire
		n += 1
	case *HeaderMatcher_PrefixMatch:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.PrefixMatch)))
		n += len(x.PrefixMatch)
	case *HeaderMatcher_SuffixMatch:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.SuffixMatch)))
		n += len(x.SuffixMatch)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type HeaderMatcher_Int64Range struct {
	Start                int64    `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End                  int64    `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeaderMatcher_Int64Range) Reset()         { *m = HeaderMatcher_Int64Range{} }
func (m *HeaderMatcher_Int64Range) String() string { return proto.CompactTextString(m) }
func (*HeaderMatcher_Int64Range) ProtoMessage()    {}
func (*HeaderMatcher_Int64Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_2beeb35319d81284, []int{2, 0}
}
func (m *HeaderMatcher_Int64Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderMatcher_Int64Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeaderMatcher_Int64Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeaderMatcher_Int64Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderMatcher_Int64Range.Merge(m, src)
}
func (m *HeaderMatcher_Int64Range) XXX_Size() int {
	return m.Size()
}
func (m *HeaderMatcher_Int64Range) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderMatcher_Int64Range.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderMatcher_Int64Range proto.InternalMessageInfo

func (m *HeaderMatcher_Int64Range) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *HeaderMatcher_Int64Range) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func init() {
	proto.RegisterType((*RateLimits)(nil), "istio.networking.v1alpha3.RateLimits")
	proto.RegisterType((*RateLimit)(nil), "istio.networking.v1alpha3.RateLimit")
	proto.RegisterType((*RateLimit_Action)(nil), "istio.networking.v1alpha3.RateLimit.Action")
	proto.RegisterType((*RateLimit_Action_SourceCluster)(nil), "istio.networking.v1alpha3.RateLimit.Action.SourceCluster")
	proto.RegisterType((*RateLimit_Action_DestinationCluster)(nil), "istio.networking.v1alpha3.RateLimit.Action.DestinationCluster")
	proto.RegisterType((*RateLimit_Action_RequestHeaders)(nil), "istio.networking.v1alpha3.RateLimit.Action.RequestHeaders")
	proto.RegisterType((*RateLimit_Action_RemoteAddress)(nil), "istio.networking.v1alpha3.RateLimit.Action.RemoteAddress")
	proto.RegisterType((*RateLimit_Action_GenericKey)(nil), "istio.networking.v1alpha3.RateLimit.Action.GenericKey")
	proto.RegisterType((*RateLimit_Action_HeaderValueMatch)(nil), "istio.networking.v1alpha3.RateLimit.Action.HeaderValueMatch")
	proto.RegisterType((*HeaderMatcher)(nil), "istio.networking.v1alpha3.HeaderMatcher")
	proto.RegisterType((*HeaderMatcher_Int64Range)(nil), "istio.networking.v1alpha3.HeaderMatcher.Int64Range")
}

func init() {
	proto.RegisterFile("networking/v1alpha3/extension_struct.proto", fileDescriptor_2beeb35319d81284)
}

var fileDescriptor_2beeb35319d81284 = []byte{
	// 794 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xd1, 0x6e, 0xe3, 0x44,
	0x14, 0x8d, 0xeb, 0xb4, 0x4d, 0xae, 0x9b, 0x36, 0x1a, 0x56, 0x28, 0x58, 0xa8, 0x64, 0x0b, 0x2b,
	0x05, 0x10, 0x8e, 0xd8, 0xae, 0x16, 0x81, 0x00, 0x69, 0x03, 0x2b, 0xc2, 0x16, 0x78, 0x98, 0x95,
	0x56, 0xc0, 0x8b, 0x35, 0xb5, 0x6f, 0x9c, 0xd1, 0x3a, 0xb6, 0x77, 0x66, 0xdc, 0x4d, 0x3e, 0x84,
	0x0f, 0xe0, 0x13, 0xf8, 0x03, 0x1e, 0x79, 0xe4, 0x13, 0x50, 0xbf, 0x04, 0xcd, 0x8c, 0x1d, 0x27,
	0x2d, 0xac, 0x9a, 0x37, 0xcf, 0x99, 0x7b, 0xcf, 0xb9, 0x73, 0xe6, 0xce, 0x35, 0x7c, 0x94, 0xa1,
	0x7a, 0x9d, 0x8b, 0x97, 0x3c, 0x4b, 0xc6, 0x57, 0x9f, 0xb2, 0xb4, 0x98, 0xb3, 0xf3, 0x31, 0x2e,
	0x15, 0x66, 0x92, 0xe7, 0x59, 0x28, 0x95, 0x28, 0x23, 0x15, 0x14, 0x22, 0x57, 0x39, 0x79, 0x87,
	0x4b, 0xc5, 0xf3, 0xa0, 0xc9, 0x08, 0xea, 0x0c, 0xff, 0x34, 0xc9, 0xf3, 0x24, 0xc5, 0xb1, 0x09,
	0xbc, 0x2c, 0x67, 0xe3, 0xb8, 0x14, 0x4c, 0xf1, 0x3c, 0xb3, 0xa9, 0xb7, 0xf7, 0x5f, 0x0b, 0x56,
	0x14, 0x28, 0x64, 0xb5, 0xff, 0xee, 0xcd, 0xfd, 0x4d, 0xe1, 0xb3, 0xe7, 0x00, 0x94, 0x29, 0xfc,
	0x81, 0x2f, 0xb8, 0x92, 0xe4, 0x29, 0x78, 0x82, 0x29, 0x0c, 0x53, 0xb3, 0x1c, 0x7c, 0x32, 0x74,
	0x47, 0xde, 0xc3, 0x0f, 0x82, 0xff, 0x2d, 0x2e, 0x58, 0xe7, 0x52, 0x10, 0x6b, 0x9a, 0xb3, 0xdf,
	0xbb, 0xd0, 0x5d, 0xef, 0x90, 0x7b, 0xb0, 0x2f, 0x15, 0x4b, 0x70, 0xe0, 0x0c, 0x9d, 0xd1, 0x3e,
	0xb5, 0x0b, 0xf2, 0x1e, 0x78, 0x31, 0x97, 0xec, 0x32, 0xc5, 0xf0, 0x25, 0xae, 0x06, 0x7b, 0x43,
	0x67, 0xd4, 0xa5, 0x50, 0x41, 0x17, 0xb8, 0x22, 0x4f, 0xe1, 0x90, 0x45, 0xfa, 0x9c, 0x72, 0xe0,
	0x9a, 0x3a, 0x3e, 0xbe, 0x4b, 0x1d, 0xc1, 0x13, 0x93, 0x43, 0xeb, 0x5c, 0xff, 0xb7, 0x0e, 0x1c,
	0x58, 0x8c, 0x5c, 0xc2, 0xb1, 0xcc, 0x4b, 0x11, 0x61, 0x18, 0xa5, 0xa5, 0x54, 0x28, 0x4c, 0x45,
	0xde, 0xc3, 0xcf, 0x77, 0x20, 0x0e, 0x9e, 0x1b, 0x86, 0x6f, 0x2c, 0xc1, 0xb4, 0x45, 0x7b, 0x72,
	0x13, 0x20, 0xaf, 0xe0, 0xad, 0x18, 0xa5, 0xe2, 0x99, 0xb9, 0xa2, 0xb5, 0xd0, 0x9e, 0x11, 0xfa,
	0x7a, 0x17, 0xa1, 0x6f, 0x1b, 0x9a, 0x46, 0x8d, 0xc4, 0xb7, 0x50, 0x82, 0x70, 0x22, 0xf0, 0x55,
	0x89, 0x52, 0x85, 0x73, 0x64, 0x31, 0x0a, 0x6d, 0x98, 0x96, 0xfb, 0x62, 0x17, 0x39, 0x6a, 0x29,
	0xa6, 0x96, 0x61, 0xda, 0xa2, 0xc7, 0x62, 0x0b, 0xd1, 0xee, 0x09, 0x5c, 0xe4, 0x0a, 0x43, 0x16,
	0xc7, 0x02, 0xa5, 0x1c, 0xb4, 0x77, 0x77, 0x8f, 0x1a, 0x86, 0x27, 0x96, 0x40, 0xbb, 0x27, 0x36,
	0x01, 0xf2, 0x0b, 0x78, 0x09, 0x66, 0x28, 0x78, 0x64, 0x9a, 0x62, 0xdf, 0x08, 0x3c, 0xde, 0x45,
	0xe0, 0x3b, 0x9b, 0x7e, 0x81, 0xab, 0x69, 0x8b, 0x42, 0xb2, 0x5e, 0x91, 0x14, 0x88, 0x75, 0x27,
	0xbc, 0x62, 0x69, 0x89, 0xe1, 0x82, 0xa9, 0x68, 0x3e, 0x38, 0x30, 0x0a, 0x5f, 0xee, 0xa2, 0x60,
	0xfd, 0x78, 0xa1, 0x49, 0x7e, 0xd4, 0x1c, 0xd3, 0x16, 0xed, 0xcf, 0x6f, 0x60, 0xfe, 0x09, 0xf4,
	0xb6, 0x1a, 0xc5, 0xbf, 0x07, 0xe4, 0xf6, 0x85, 0xfa, 0x3f, 0xc3, 0xf1, 0xb6, 0xef, 0xfa, 0x59,
	0x54, 0x65, 0x66, 0x6c, 0x61, 0x9f, 0x4c, 0x97, 0x82, 0x85, 0x7e, 0x62, 0x0b, 0x24, 0x0f, 0xe0,
	0x38, 0x46, 0x19, 0x09, 0x5e, 0xa8, 0x5c, 0x6c, 0x3c, 0x9d, 0x5e, 0x83, 0x5e, 0xe0, 0x4a, 0x17,
	0xb0, 0xe5, 0xb5, 0xff, 0x19, 0x40, 0xe3, 0x0d, 0xf9, 0x10, 0xfa, 0x1b, 0x2c, 0xc6, 0x91, 0x4a,
	0xeb, 0xa4, 0xc1, 0xcd, 0x79, 0xfc, 0x3f, 0x1d, 0xe8, 0xdf, 0x3c, 0xf3, 0x0e, 0xf9, 0xe4, 0x2b,
	0x38, 0xc2, 0x65, 0x81, 0x91, 0xaa, 0x2c, 0xb7, 0x4f, 0xc1, 0x0f, 0xec, 0x58, 0x0a, 0xea, 0xb1,
	0x14, 0x4c, 0xf2, 0x3c, 0x35, 0x19, 0xd4, 0xb3, 0xf1, 0x56, 0x69, 0x02, 0x87, 0x4d, 0x57, 0xeb,
	0x31, 0x30, 0x7a, 0xc3, 0x65, 0xd9, 0x3a, 0x4d, 0x22, 0x0a, 0x5a, 0x27, 0x4e, 0x08, 0xf4, 0xed,
	0x38, 0x08, 0x65, 0x81, 0x11, 0x9f, 0x71, 0x14, 0x67, 0x7f, 0xb8, 0xd0, 0xdb, 0x0a, 0x27, 0x04,
	0xda, 0x1b, 0x9e, 0x9b, 0x6f, 0x72, 0x1f, 0x3c, 0x5c, 0xb2, 0x75, 0xed, 0xba, 0xe3, 0xbb, 0xba,
	0xb1, 0x0c, 0x68, 0x0b, 0xbc, 0x0f, 0x9e, 0xc0, 0x04, 0x97, 0x55, 0xc8, 0x7e, 0x1d, 0x62, 0x40,
	0x1b, 0xf2, 0x42, 0x8f, 0xd5, 0x2c, 0xd9, 0x6e, 0xba, 0xf3, 0xbb, 0x9e, 0x23, 0xf8, 0x3e, 0x53,
	0x8f, 0x1f, 0x51, 0x4d, 0x60, 0x78, 0xf5, 0x87, 0xe5, 0x7d, 0x00, 0xbd, 0x42, 0xa0, 0xc4, 0xac,
	0xae, 0xef, 0x70, 0xe8, 0x8c, 0x3a, 0xd3, 0x16, 0x3d, 0xaa, 0x60, 0x1b, 0xf6, 0x3e, 0xe8, 0xf5,
	0x8c, 0xd7, 0x25, 0x76, 0xab, 0x12, 0x3d, 0x8b, 0xae, 0x83, 0x64, 0x39, 0x6b, 0x82, 0xa0, 0x0e,
	0xb2, 0x68, 0x7d, 0xd6, 0x23, 0x9e, 0x5d, 0xa1, 0xa8, 0xf5, 0x3a, 0x5a, 0x8f, 0x7a, 0x16, 0xb3,
	0x9d, 0xff, 0x08, 0xa0, 0xa9, 0xb7, 0x9a, 0xfd, 0x42, 0x19, 0x53, 0x5d, 0x6a, 0x17, 0xa4, 0x0f,
	0x2e, 0x66, 0xb1, 0xe9, 0x04, 0x97, 0xea, 0xcf, 0xc9, 0x00, 0xde, 0xae, 0xda, 0xde, 0x10, 0x37,
	0xf7, 0xf4, 0xac, 0xdd, 0xd9, 0xeb, 0xbb, 0xcf, 0xda, 0x1d, 0xb7, 0xdf, 0x9e, 0x04, 0x7f, 0x5d,
	0x9f, 0x3a, 0x7f, 0x5f, 0x9f, 0x3a, 0xff, 0x5c, 0x9f, 0x3a, 0xbf, 0x0e, 0xad, 0x7f, 0x3c, 0x1f,
	0xb3, 0x82, 0x8f, 0xff, 0xe3, 0x67, 0x7b, 0x79, 0x60, 0x9a, 0xeb, 0xfc, 0xdf, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x2e, 0xac, 0x91, 0xd2, 0x8a, 0x07, 0x00, 0x00,
}

func (m *RateLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RateLimits) > 0 {
		for iNdEx := len(m.RateLimits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExtensionStruct(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xea
		}
	}
	return len(dAtA) - i, nil
}

func (m *RateLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Actions) > 0 {
		for iNdEx := len(m.Actions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Actions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExtensionStruct(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.DisableKey) > 0 {
		i -= len(m.DisableKey)
		copy(dAtA[i:], m.DisableKey)
		i = encodeVarintExtensionStruct(dAtA, i, uint64(len(m.DisableKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.Stage != 0 {
		i = encodeVarintExtensionStruct(dAtA, i, uint64(m.Stage))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RateLimit_Action) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit_Action) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ActionSpecifier != nil {
		{
			size := m.ActionSpecifier.Size()
			i -= size
			if _, err := m.ActionSpecifier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RateLimit_Action_SourceCluster_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RateLimit_Action_SourceCluster_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SourceCluster != nil {
		{
			size, err := m.SourceCluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExtensionStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RateLimit_Action_DestinationCluster_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RateLimit_Action_DestinationCluster_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DestinationCluster != nil {
		{
			size, err := m.DestinationCluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExtensionStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RateLimit_Action_RequestHeaders_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RateLimit_Action_RequestHeaders_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RequestHeaders != nil {
		{
			size, err := m.RequestHeaders.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExtensionStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RateLimit_Action_RemoteAddress_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RateLimit_Action_RemoteAddress_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RemoteAddress != nil {
		{
			size, err := m.RemoteAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExtensionStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RateLimit_Action_GenericKey_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RateLimit_Action_GenericKey_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GenericKey != nil {
		{
			size, err := m.GenericKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExtensionStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *RateLimit_Action_HeaderValueMatch_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RateLimit_Action_HeaderValueMatch_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HeaderValueMatch != nil {
		{
			size, err := m.HeaderValueMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExtensionStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *RateLimit_Action_SourceCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action_SourceCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit_Action_SourceCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RateLimit_Action_DestinationCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action_DestinationCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit_Action_DestinationCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RateLimit_Action_RequestHeaders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action_RequestHeaders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit_Action_RequestHeaders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DescriptorKey) > 0 {
		i -= len(m.DescriptorKey)
		copy(dAtA[i:], m.DescriptorKey)
		i = encodeVarintExtensionStruct(dAtA, i, uint64(len(m.DescriptorKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HeaderName) > 0 {
		i -= len(m.HeaderName)
		copy(dAtA[i:], m.HeaderName)
		i = encodeVarintExtensionStruct(dAtA, i, uint64(len(m.HeaderName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RateLimit_Action_RemoteAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action_RemoteAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit_Action_RemoteAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RateLimit_Action_GenericKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action_GenericKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit_Action_GenericKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DescriptorValue) > 0 {
		i -= len(m.DescriptorValue)
		copy(dAtA[i:], m.DescriptorValue)
		i = encodeVarintExtensionStruct(dAtA, i, uint64(len(m.DescriptorValue)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RateLimit_Action_HeaderValueMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit_Action_HeaderValueMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit_Action_HeaderValueMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExtensionStruct(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ExpectMatch != nil {
		{
			size, err := m.ExpectMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExtensionStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.DescriptorValue) > 0 {
		i -= len(m.DescriptorValue)
		copy(dAtA[i:], m.DescriptorValue)
		i = encodeVarintExtensionStruct(dAtA, i, uint64(len(m.DescriptorValue)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeaderMatcher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HeaderMatchSpecifier != nil {
		{
			size := m.HeaderMatchSpecifier.Size()
			i -= size
			if _, err := m.HeaderMatchSpecifier.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.InvertMatch {
		i--
		if m.InvertMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintExtensionStruct(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeaderMatcher_ExactMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HeaderMatcher_ExactMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ExactMatch)
	copy(dAtA[i:], m.ExactMatch)
	i = encodeVarintExtensionStruct(dAtA, i, uint64(len(m.ExactMatch)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *HeaderMatcher_RegexMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HeaderMatcher_RegexMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.RegexMatch)
	copy(dAtA[i:], m.RegexMatch)
	i = encodeVarintExtensionStruct(dAtA, i, uint64(len(m.RegexMatch)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *HeaderMatcher_RangeMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HeaderMatcher_RangeMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RangeMatch != nil {
		{
			size, err := m.RangeMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExtensionStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *HeaderMatcher_PresentMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HeaderMatcher_PresentMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.PresentMatch {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	return len(dAtA) - i, nil
}
func (m *HeaderMatcher_PrefixMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HeaderMatcher_PrefixMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.PrefixMatch)
	copy(dAtA[i:], m.PrefixMatch)
	i = encodeVarintExtensionStruct(dAtA, i, uint64(len(m.PrefixMatch)))
	i--
	dAtA[i] = 0x4a
	return len(dAtA) - i, nil
}
func (m *HeaderMatcher_SuffixMatch) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *HeaderMatcher_SuffixMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.SuffixMatch)
	copy(dAtA[i:], m.SuffixMatch)
	i = encodeVarintExtensionStruct(dAtA, i, uint64(len(m.SuffixMatch)))
	i--
	dAtA[i] = 0x52
	return len(dAtA) - i, nil
}
func (m *HeaderMatcher_Int64Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderMatcher_Int64Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcher_Int64Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.End != 0 {
		i = encodeVarintExtensionStruct(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintExtensionStruct(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintExtensionStruct(dAtA []byte, offset int, v uint64) int {
	offset -= sovExtensionStruct(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RateLimits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RateLimits) > 0 {
		for _, e := range m.RateLimits {
			l = e.Size()
			n += 2 + l + sovExtensionStruct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Stage != 0 {
		n += 1 + sovExtensionStruct(uint64(m.Stage))
	}
	l = len(m.DisableKey)
	if l > 0 {
		n += 1 + l + sovExtensionStruct(uint64(l))
	}
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovExtensionStruct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimit_Action) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionSpecifier != nil {
		n += m.ActionSpecifier.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimit_Action_SourceCluster_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SourceCluster != nil {
		l = m.SourceCluster.Size()
		n += 1 + l + sovExtensionStruct(uint64(l))
	}
	return n
}
func (m *RateLimit_Action_DestinationCluster_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DestinationCluster != nil {
		l = m.DestinationCluster.Size()
		n += 1 + l + sovExtensionStruct(uint64(l))
	}
	return n
}
func (m *RateLimit_Action_RequestHeaders_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestHeaders != nil {
		l = m.RequestHeaders.Size()
		n += 1 + l + sovExtensionStruct(uint64(l))
	}
	return n
}
func (m *RateLimit_Action_RemoteAddress_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemoteAddress != nil {
		l = m.RemoteAddress.Size()
		n += 1 + l + sovExtensionStruct(uint64(l))
	}
	return n
}
func (m *RateLimit_Action_GenericKey_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GenericKey != nil {
		l = m.GenericKey.Size()
		n += 1 + l + sovExtensionStruct(uint64(l))
	}
	return n
}
func (m *RateLimit_Action_HeaderValueMatch_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeaderValueMatch != nil {
		l = m.HeaderValueMatch.Size()
		n += 1 + l + sovExtensionStruct(uint64(l))
	}
	return n
}
func (m *RateLimit_Action_SourceCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimit_Action_DestinationCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimit_Action_RequestHeaders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HeaderName)
	if l > 0 {
		n += 1 + l + sovExtensionStruct(uint64(l))
	}
	l = len(m.DescriptorKey)
	if l > 0 {
		n += 1 + l + sovExtensionStruct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimit_Action_RemoteAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimit_Action_GenericKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DescriptorValue)
	if l > 0 {
		n += 1 + l + sovExtensionStruct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimit_Action_HeaderValueMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DescriptorValue)
	if l > 0 {
		n += 1 + l + sovExtensionStruct(uint64(l))
	}
	if m.ExpectMatch != nil {
		l = m.ExpectMatch.Size()
		n += 1 + l + sovExtensionStruct(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovExtensionStruct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeaderMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovExtensionStruct(uint64(l))
	}
	if m.HeaderMatchSpecifier != nil {
		n += m.HeaderMatchSpecifier.Size()
	}
	if m.InvertMatch {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeaderMatcher_ExactMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExactMatch)
	n += 1 + l + sovExtensionStruct(uint64(l))
	return n
}
func (m *HeaderMatcher_RegexMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RegexMatch)
	n += 1 + l + sovExtensionStruct(uint64(l))
	return n
}
func (m *HeaderMatcher_RangeMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeMatch != nil {
		l = m.RangeMatch.Size()
		n += 1 + l + sovExtensionStruct(uint64(l))
	}
	return n
}
func (m *HeaderMatcher_PresentMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *HeaderMatcher_PrefixMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrefixMatch)
	n += 1 + l + sovExtensionStruct(uint64(l))
	return n
}
func (m *HeaderMatcher_SuffixMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SuffixMatch)
	n += 1 + l + sovExtensionStruct(uint64(l))
	return n
}
func (m *HeaderMatcher_Int64Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovExtensionStruct(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovExtensionStruct(uint64(m.End))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovExtensionStruct(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozExtensionStruct(x uint64) (n int) {
	return sovExtensionStruct(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RateLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExtensionStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimits = append(m.RateLimits, &RateLimit{})
			if err := m.RateLimits[len(m.RateLimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExtensionStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExtensionStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			m.Stage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisableKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &RateLimit_Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExtensionStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExtensionStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimit_Action_SourceCluster{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionSpecifier = &RateLimit_Action_SourceCluster_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimit_Action_DestinationCluster{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionSpecifier = &RateLimit_Action_DestinationCluster_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimit_Action_RequestHeaders{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionSpecifier = &RateLimit_Action_RequestHeaders_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimit_Action_RemoteAddress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionSpecifier = &RateLimit_Action_RemoteAddress_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenericKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimit_Action_GenericKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionSpecifier = &RateLimit_Action_GenericKey_{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderValueMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimit_Action_HeaderValueMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionSpecifier = &RateLimit_Action_HeaderValueMatch_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExtensionStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action_SourceCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExtensionStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipExtensionStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action_DestinationCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExtensionStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DestinationCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DestinationCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipExtensionStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action_RequestHeaders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExtensionStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestHeaders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestHeaders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescriptorKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExtensionStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action_RemoteAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExtensionStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipExtensionStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action_GenericKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExtensionStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenericKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenericKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescriptorValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExtensionStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit_Action_HeaderValueMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExtensionStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderValueMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderValueMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescriptorValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpectMatch == nil {
				m.ExpectMatch = &types.BoolValue{}
			}
			if err := m.ExpectMatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &HeaderMatcher{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExtensionStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderMatcher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExtensionStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderMatcher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderMatcher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactMatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderMatchSpecifier = &HeaderMatcher_ExactMatch{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegexMatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderMatchSpecifier = &HeaderMatcher_RegexMatch{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HeaderMatcher_Int64Range{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HeaderMatchSpecifier = &HeaderMatcher_RangeMatch{v}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PresentMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.HeaderMatchSpecifier = &HeaderMatcher_PresentMatch{b}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatch = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixMatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderMatchSpecifier = &HeaderMatcher_PrefixMatch{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuffixMatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderMatchSpecifier = &HeaderMatcher_SuffixMatch{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExtensionStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderMatcher_Int64Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExtensionStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int64Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int64Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExtensionStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExtensionStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipExtensionStruct(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowExtensionStruct
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExtensionStruct
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthExtensionStruct
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthExtensionStruct
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowExtensionStruct
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipExtensionStruct(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthExtensionStruct
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthExtensionStruct = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowExtensionStruct   = fmt.Errorf("proto: integer overflow")
)
